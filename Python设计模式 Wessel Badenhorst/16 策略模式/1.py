def reducer(arg1, arg2, strategy=None):
	if strategy == "add":
		print(arg1 + arg2)
	elif strategy == "sub":
		print(arg1 - arg2)
	else:
		print("Strategy is not implemented...")


def main():
	reducer(1, 3)
	reducer(2, 4, "sub")
	reducer(2, 4, "add")


if __name__ == '__main__':
	main()
"""
这就是我们所希望的。可惜的是,我们会遭遇前面章节中所遇到的相同问题,
也就是说,无论何时希望将另一条策略添加到这个reducer,都必须将另一个ei语句添加到该函数,
并且添加另一块代码来处理该策略。这必然会导致订语句无序蔓延。我们更倾向于使用一种更为模块化的解决方案,
它允许我们在运行时传入新的策略而不必修改使用或者执行该策略的代码。
正如大家目前期望的那样,有一种设计模式可以专门应对这一局面。
这个设计模式被贴切地命名为策略模式,因为它允许编写使用一些策略的代码,
以便在运行时进行选择,而除了它要遵循一些执行特征之外,不需要知道关于该策略的任何信息。
同样,要借助于一个对象来帮助我们解决这个问题。我们还要再阐述一遍这一事实,
即Python会将函数作为等级最优先的对象来处理,这将使这个设计模式的实现变得远远清晰于最初的实现。
我们将首先介绍策略模式的传统实现。
"""