工厂模式:
    我们希望通过一个通用接口来创建对象,而不是让创建代码分散在整个系统中.这样就能在更新可以
    被创建的形状类型时定位到需要修改的代码.

    创建一个集中式的系统来进行对象创建的一种方式就是使用工厂模式.

    !在开始工厂模式之前,注意一点:
        原型模式和工厂模式之间存在一个主要区别.
            原型模式不需要子类化,不过需要一个初始化操作.
            而工厂模式需要子类化,不需要初始化.
            他们,各有优势,理解差异,适时选择.


    无论我们何时在游戏中添加一个需要在屏幕上绘制的新类,只需要修改factory()方法即可.


抽象工厂:
    当需要不同类型的工厂时呢?可能我们需要添加声音效果工厂?我们希望能够从相同的基础工厂中创建不同类型的工厂子类.

    当希望创建单个接口来访问整个工厂集合时,可以毫无顾忌的使用一个抽象工厂.当集合中的每个抽象工厂都需要实现一个预定义接口,
    并且就每种工厂方法模式而言,该接口的每个函数都会返回另一个抽象类型.


工厂模式和抽象工厂的区别:
    工厂是对产品(对象)类的抽象
    抽象工厂是对工厂类的进一步抽象.





总结:
    在开发软件时,我们希望避免一种令人失落的情绪,就是说

    我们最好不要认为应该构建出一个能够最终迎合未来每一种可能性的软件。

    虽然思考我们所编写软件的未来是很好的习惯，不过通常,
    尝试构建出一个非常通用以致能够解决未来每一项可能需求的软件的做法都是徒劳的。
    最显的原因就是,我们没有办法预想到软件来会变成什么样子。
    这并不是说我们应该天真地不去考虑代码在短期内的发展方向,而是说,

    演化代码以便纳入新功能的能力

    才是软件开发人员的其中一项最有价值的技能。
    大部分人往往会倾向于完全抛开之前所编写的老代码,并且重新开始“编写所谓的正确代码”。
    这完全是在做梦,在我们这样做时,我们又会了解到一些新内容,而这些东西又会让我们的代码不再那么优雅,
    因而我们又不得不重新开始,而永远无法完成任何工作。

    总的原则就是 YAGNI .作为软件开发人员,我们很可能会在职业生涯中碰到这一缩写词。它的含义是什么?

    答案就是-我们并不需要它!

    这个原则就是,我们应该编写能很好地解决当前问题的代码,并且对于这些代码,仅需要考虑为了解决后续问题而做修改的情况。
    因而,许多软件设计一开始都只使用较简单的工厂方法,并且仅在开发人员发现需要更多的灵活性时,才会对程序进行演化,
    以便使用抽象工厂,原型或建造者模式.


