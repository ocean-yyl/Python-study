# 20,异常处理及程序调试
"""
常见异常类型：
AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x
IOError 输入/输出异常；基本上是无法打开文件
ImportError 无法引入模块或包；基本上是路径问题或名称错误
IndentationError 语法错误（的子类） ；代码没有正确对齐
IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]
KeyError 试图访问字典里不存在的键
KeyboardInterrupt Ctrl+C被按下
NameError 使用一个还未被赋予对象的变量
SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）
TypeError 传入对象类型与要求的不符合
UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它
ValueError 传入一个调用者不期望的值，即使值的类型是正确的

"""

# 1，异常处理语句
# 1.1    try...except语句
try:
    a = 2 / 0
except (ValueError, ZeroDivisionError, TypeError) as erro:
    print("出错了――0不能做除数！")
    print("异常信息为：", erro)

# 1.2    try...except..else语句，else字句在try语句运行正常时执行。
try:
    a = 2 / 1
except (ValueError, ZeroDivisionError, TypeError) as erro:
    print("出错了――0不能做除数！")
    print("异常信息为：", erro)
else:
    print("a=", a)

# 1.3    try...except...finally语句，无论程序有无异常产生，finally中的代码块都会被执行。（一般来说，finally字句是为了执行清理代码，清理资源或内存）
"""
不要在try else里写返回值。如果没有finally，就写在最后，或者只写在finally里。
try块中包含break、continue或者return语句的，在离开try块之前，finally中的语句也会被执行。

“如果try中没有异常，那么except部分将跳过，执行else中的语句。（前提是try里没有返回值）
finally是无论是否有异常，最后都要做的一些事情。”（无论try里是否有返回值）
在含有return的情况下，并不会阻碍finally的执行。（但是会阻碍else）
"""

# 1.4    try...except...else...finally语句

# 2，使用raise语句抛出异常
try:
    a = 8
    b = -1
    if a * b < 0:
        raise ValueError("错误，a或b不可以是负值！")
    else:
        print("a/b=", a / b)
except (ValueError, ZeroDivisionError, TypeError) as erro:
    print("出错了")
    print("异常信息为：", erro)

# 3，程序调试
# 使用assert语句调试程序. assert expression [,reason]。
# assert 语句只在调试阶段有效。我们可以在执行python命令时加入-O（大写）参数来关闭assert语句。
"""
assert的语法格式：   assert expression
它的等价语句为：
if not expression:
    raise AssertionError
"""

try:
    a = 8
    b = -1
    assert (a * b > 0), "错误，a或b不可以是负值！"
    print("a/b=",a/b)
except AssertionError as erro:
    print("assert")
    print("异常信息为：", erro)
